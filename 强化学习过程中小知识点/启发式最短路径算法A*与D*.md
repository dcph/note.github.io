最短路径的计算分静态最短路计算和动态最短路计算。静态路径最短路径算法是外界环境不变，计算最短路径。主要有Dijkstra算法，A*（A Star）算法。
动态路径最短路是外界环境不断发生变化，即不能计算预测的情况下计算最短路。如在游戏中敌人或障碍物不断移动的情况下，典型的有D* 算法。
在po模型中，通过将未知的环境看做一种一致仿真的已知环境，在与环境进行交互中对未知环境的更新看做外界环境的变化，可以将po问题在一定的模型中转化为动态最短路计算问题，可以使用D* 算法进行求解。

A* 算法

路径规划中想找从一个位置到另一个位置的路径。不仅试图找到其中最短的路径，还希望考虑到时间成本，实现的最简单的方法就是图遍历搜索算法，广度优先或深度优先（BFS和DFS）。
A* 算法只看图的数据，A* 会告诉你从一个位置移动到另一个位置，但是不会告诉你如何移动过去，如果是网格类游戏，那么可以将一个网格设置为一次移动的基本量，如果是开放世界的类型，那么需要自己设计网格，或者通过数学公式建模得到移动方向和方式。

计算过程可以简述为在每个点选取周围每个潜在的点加入待检查列表，并按权重依次检查，不符合就标记跳过，符合就进入下一个点 重复计算此过程(该过程可回溯)，检查方式为计算F=G+H。G为计算从起点A移动到指定方格的移动代价，沿着到达该方格而生成的路径。H为从指定的方格移动到终点B的估算成本，这个只是一个估测，直到我们找到了路径我们才会知道真正的距离，因为途中有各种各样的东西 ( 比如墙壁，水等 )。然后反复遍历list ，选择F值最小的方格，其中H的计算有各种方式，比如曼哈顿距离等等。

具体可见链接：
https://link.zhihu.com/?target=https%3A//github.com/yangruihan/Notes/blob/master/GameDevelopment/GameDevelop/AStar%25E7%25AE%2597%25E6%25B3%2595%25E4%25BB%258B%25E7%25BB%258D.md

D* 算法

是A* 算法的更新，是一种启发式的路径搜索算法，适合面对周围环境未知或者周围环境存在动态变化的场景。特点是与A相反，A从起点到目标点进行搜索，而D是从目标点向起点进行搜索——反向传播，反向搜索。D* 由于储存了空间中每个点到终点的最短路径信息，故在重规划时效率大大提升。

同A* 算法类似，D-star通过一个维护一个优先队列（OpenList）来对场景中的路径节点进行搜索，所不同的是，D* 不是由起始点开始搜索，而是以目标点为起始，通过将目标点置于Openlist中来开始搜索，直到机器人当前位置节点由队列中出队为止（当然如果中间某节点状态有动态改变，需要重新寻路，所以才是一个动态寻路算法）。

里面的节点被称为state,每个state有如值：tag:new,open,closed

分别标识三类节点，分别标识没有加入过open表的、在open表的、曾经在open表但现在已经被移走的。一开始所有的点的tag初值为new，当被加入到open表之后，被置为‘open’ ， 从open表移走，被置为‘closed’

h: 每个点的h值代表当前该点，到终点，也就是目标点G的代价。第一次搜索到起点时时，所有点的h会被更新，计算方式同dijkstr算法，是用相邻两点的代价+上一个点的代价累加得到。

k: 该点最小的h值。k的计算在更新过本节点的h后，如果本点‘new’,k=h；如果本点’open’，那就取一下当前k和new_h最小值，如果本点是’closed’，取当前h和new_h最小值； 总而言之，k将会保持到最小，它表示了本点在全图环境中到G点的最小代价。

在移动的下一节点没有变化时，无需计算，利用上一步Dijstra计算出的最短路信息从出发点向后追述即可，当在Y点探测到下一节点X状态发生改变，如堵塞。机器人首先调整自己在当前位置Y到目标点G的实际值h(Y)，h(Y)=X到Y的新权值c(X,Y)+X的原实际值h(X).X为下一节点(到目标点方向Y->X->G），Y是当前点。k值取h值变化前后的最小。其中计算假设使用用A* 计算,遍历Y的子节点，点放入CLOSE,调整Y的子节点a的h值，h(a)=h(Y)+Y到子节点a的权重C(Y,a),比较a点是否存在于OPEN和CLOSE中，方法如下：
![Image text](/强化学习过程中小知识点/images/a3.png )
